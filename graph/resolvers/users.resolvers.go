package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"client_task/graph/customTypes"
	"client_task/graph/generated"
	db_sqlc "client_task/pkg/common/db/sqlc"
	"context"
	"errors"
	"fmt"
	"strings"

	"client_task/pkg/controllers"

	"github.com/jackc/pgx/v5/pgtype"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, user customTypes.CreateUserInput) (*customTypes.User, error) {
	// conn, err := db.Connect(ctx)
	// db := db_sqlc.New(conn)
	fmt.Println("user", user)
	existingUser, err := r.DB.GetUserByEmail(ctx, user.Email)
	if err != nil && !isSQLError(err, "no rows in result set") {
		return nil, err
	}

	if existingUser != emptyUser {
		return nil, fmt.Errorf("user with email %s already exists", user.Email)
	}

	userRole, err := convertStringToUserRole(user.Role.String())
	fmt.Println("userRole", userRole)
	if err != nil {
		return nil, fmt.Errorf("invalid user type: %w", err)
	}

	hashedPassword, err := controllers.HashPassword(user.Password)
	if err != nil {
		return nil, fmt.Errorf("enable to encrypt password: %w", err)
	}

	prm := &db_sqlc.CreateUserParams{
		FullName:     user.FullName,
		Email:        user.Email,
		PasswordHash: hashedPassword,
		UserType:     userRole,
	}
	fmt.Println(prm)
	user1, err := r.DB.CreateUser(ctx, *prm)
	fmt.Println(user1)
	user_obj := &customTypes.User{
		FullName:  user1.FullName,
		Email:     user1.Email,
		ID:        int(user1.ID),
		CreatedAt: user1.CreatedAt.Time.String(),
		Role:      customTypes.UserRole(user1.UserType),
	}
	if err != nil {
		return nil, err
	}
	return user_obj, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, id int, user customTypes.UpdateUserInput) (*customTypes.User, error) {
	prm := &db_sqlc.UpdateUserParams{
		ID:       int32(id),
		FullName: *user.FullName,
	}

	user1, err := r.DB.UpdateUser(ctx, *prm)
	fmt.Println(user1)
	user_obj := &customTypes.User{
		FullName:  user1.FullName,
		Email:     user1.Email,
		ID:        int(user1.ID),
		CreatedAt: user1.CreatedAt.Time.String(),
	}
	if err != nil {
		return nil, err
	}
	return user_obj, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id int) (bool, error) {
	// Check user existence
	user, err := r.DB.GetUserByID(ctx, int32(id))
	if err != nil {
		if !isSQLError(err, "no user found with this ID") {
			return false, err
		}
		// User not found, return specific error message
		return false, fmt.Errorf("user with ID %d not found", id)
	}
	fmt.Println("user", user)

	// Delete user
	err = r.DB.DeleteUserByID(ctx, int32(id))
	if err != nil {
		return false, err
	}

	return true, nil
}

func AddSkillToUser(ctx context.Context, db *db_sqlc.Queries, skills []string, user_id int32) {
	for _, skill := range skills {

		skillObj, err := db.GetSkillByName(ctx, skill)
		// fmt.Println("skill objection")
		// fmt.Println(skillObj, err.Error())
		if err != nil {
			skillObj, _ = db.CreateSkill(ctx, skill)
			// fmt.Println(skillObj)
		}

		params := &db_sqlc.GetUserSkillsByUserIDAndSkillIdParams{
			UserID:  user_id,
			SkillID: skillObj.ID,
		}

		profile_skills, err := db.GetUserSkillsByUserIDAndSkillId(ctx, *params)
		// fmt.Println("profile_skills")
		// fmt.Println(profile_skills, err.Error())
		if err != nil {

			Cparams := &db_sqlc.AddSkillToUserParams{
				UserID:  user_id,
				SkillID: skillObj.ID,
			}
			db.AddSkillToUser(ctx, *Cparams)
		}
		fmt.Println(profile_skills)

	}

}

// CreateProfile is the resolver for the createProfile field.
func (r *mutationResolver) CreateProfile(ctx context.Context, userID int, profileInput customTypes.CreateProfileInput) (*customTypes.Profile, error) {
	user_id := int32(userID)
	user_check, err := r.DB.GetUserByID(ctx, user_id)
	if err == nil {
		return nil, err

	}
	fmt.Printf(user_check.Email)

	profile_check, err := r.DB.GetProfileByUserID(ctx, user_id)
	if err == nil {
		return nil, err

	}
	fmt.Printf(profile_check.JobRole)

	args := &db_sqlc.CreateProfileParams{
		UserID:      user_id,
		Bio:         pgtype.Text{String: *profileInput.Bio, Valid: *profileInput.Bio != ""},
		Company:     pgtype.Text{String: *profileInput.Company, Valid: *profileInput.Company != ""},
		JobRole:     profileInput.JobRole,
		Description: pgtype.Text{String: *profileInput.Description, Valid: *profileInput.Description != ""},
	}

	profile, err := r.DB.CreateProfile(ctx, *args)
	if err != nil {
		return nil, errors.New("Failed creating profile: " + err.Error())

	}

	fmt.Println(profile)
	profile_obj := &customTypes.Profile{
		UserID:      int(profile.UserID),
		JobRole:     profile.JobRole,
		Company:     &profile.Company.String,
		Bio:         &profile.Bio.String,
		Description: &profile.Description.String,
	}

	AddSkillToUser(ctx, r.DB, profileInput.Skills, user_id)

	return profile_obj, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, id int, profileInput customTypes.UpdateProfileInput) (*customTypes.Profile, error) {

	args := &db_sqlc.UpdateProfileParams{
		ID:          int32(id),
		Bio:         pgtype.Text{String: *profileInput.Bio, Valid: *profileInput.Bio != ""},
		Company:     pgtype.Text{String: *profileInput.Company, Valid: *profileInput.Company != ""},
		JobRole:     *profileInput.JobRole,
		Description: pgtype.Text{String: *profileInput.Description, Valid: *profileInput.Description != ""},
	}

	profile, err := r.DB.UpdateProfile(ctx, *args)
	if err != nil {

		return nil, errors.New("Failed updating profile. error: " + err.Error())

	}
	AddSkillToUser(ctx, r.DB, profileInput.Skills, profile.UserID)
	fmt.Println(profile)
	profile_obj := &customTypes.Profile{
		UserID:      int(profile.UserID),
		JobRole:     profile.JobRole,
		Company:     &profile.Company.String,
		Bio:         &profile.Bio.String,
		Description: &profile.Description.String,
	}

	return profile_obj, nil
}

func (r *mutationResolver) DeleteProfile(ctx context.Context, id int) (bool, error) {
	// Check if profile exists
	profile, err := r.DB.GetProfileByID(ctx, int32(id))
	if err != nil {
		if isSQLError(err, "no profile found with this ID") {
			return false, fmt.Errorf("profile with ID %d not found", id)
		}
		return false, err
	}
	fmt.Printf(profile.JobRole)
	// Delete profile
	err = r.DB.DeleteProfileByID(ctx, int32(id))
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreateSkill is the resolver for the createSkill field.
func (r *mutationResolver) CreateSkill(ctx context.Context, name string) (*customTypes.Skill, error) {
	// Check if the skill already exists
	skillObj, err := r.DB.GetSkillByName(ctx, name)
	if err == nil {
		return nil, fmt.Errorf("skill '%s' already exists", name)
	}

	// If the skill doesn't exist, create it
	skillObj, err = r.DB.CreateSkill(ctx, name)
	if err != nil {
		return nil, fmt.Errorf("failed to create skill '%s': %v", name, err)
	}

	// Convert to customTypes.Skill
	skill := &customTypes.Skill{
		ID:   int(skillObj.ID),
		Name: skillObj.Name,
	}

	return skill, nil
}

// UpdateSkill is the resolver for the updateSkill field.
func (r *mutationResolver) UpdateSkill(ctx context.Context, id int, name string) (*customTypes.Skill, error) {
	// Check if the skill exists
	skillObj, err := r.DB.GetSkillByID(ctx, int32(id))
	if err != nil {
		if isSQLError(err, "no skill found with this ID") {
			return nil, fmt.Errorf("skill with ID %d not found", id)
		}
		return nil, err
	}

	// Update the skill
	skillObj, err = r.DB.UpdateSkill(ctx, db_sqlc.UpdateSkillParams{
		ID:    int32(id),
		Lower: name,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to update skill with ID %d: %v", id, err)
	}

	// Convert to customTypes.Skill
	skill := &customTypes.Skill{
		ID:   int(skillObj.ID),
		Name: skillObj.Name,
	}

	return skill, nil
}

// DeleteSkill is the resolver for the deleteSkill field.
func (r *mutationResolver) DeleteSkill(ctx context.Context, id int) (bool, error) {
	// Check if the skill exists
	_, err := r.DB.GetSkillByID(ctx, int32(id))
	if err != nil {
		if isSQLError(err, "no skill found with this ID") {
			return false, fmt.Errorf("skill with ID %d not found", id)
		}
		return false, err
	}

	// Delete the skill
	err = r.DB.DeleteSkillByID(ctx, int32(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete skill with ID %d: %v", id, err)
	}

	return true, nil
}

// CreateCareer is the resolver for the createCareer field.
func (r *mutationResolver) CreateCareer(ctx context.Context, userID int, careerInput customTypes.CreateCareerInput) (*customTypes.Career, error) {
	userIDInt32 := int32(userID)

	// Check if the user exists
	_, err := r.DB.GetUserByID(ctx, userIDInt32)
	if err != nil {
		if isSQLError(err, "no user found with this ID") {
			return nil, fmt.Errorf("user with ID %d not found", userID)
		}
		return nil, err
	}

	// Create the career
	args := db_sqlc.CreateCareerParams{
		UserID:      userIDInt32,
		Title:       careerInput.Title,
		Company:     pgtype.Text{String: *careerInput.Company, Valid: *careerInput.Company != ""},
		Description: pgtype.Text{String: *careerInput.Description, Valid: *careerInput.Description != ""},
		SkillID:     int32(careerInput.SkillID),
	}
	careerObj, err := r.DB.CreateCareer(ctx, args)
	if err != nil {
		return nil, fmt.Errorf("failed to create career: %v", err)
	}

	// Convert to customTypes.Career
	career := &customTypes.Career{
		ID:          int(careerObj.ID),
		Title:       careerObj.Title,
		Company:     &careerObj.Company.String,
		Description: &careerObj.Description.String,
	}

	return career, nil
}

// UpdateCareer is the resolver for the updateCareer field.
func (r *mutationResolver) UpdateCareer(ctx context.Context, id int, careerInput customTypes.UpdateCareerInput) (*customTypes.Career, error) {
	// Check if the career exists
	careerObj, err := r.DB.GetCareerByID(ctx, int32(id))
	if err != nil {
		if isSQLError(err, "no career found with this ID") {
			return nil, fmt.Errorf("career with ID %d not found", id)
		}
		return nil, err
	}

	// Update the career
	args := db_sqlc.UpdateCareerParams{
		ID:          int32(id),
		Title:       *careerInput.Title,
		Company:     pgtype.Text{String: *careerInput.Company, Valid: *careerInput.Company != ""},
		Description: pgtype.Text{String: *careerInput.Description, Valid: *careerInput.Description != ""},
		SkillID:     int32(*careerInput.SkillID),
	}
	careerObj, err = r.DB.UpdateCareer(ctx, args)
	if err != nil {
		return nil, fmt.Errorf("failed to update career with ID %d: %v", id, err)
	}

	// Convert to customTypes.Career
	career := &customTypes.Career{
		ID:          int(careerObj.ID),
		Title:       careerObj.Title,
		Company:     &careerObj.Company.String,
		Description: &careerObj.Description.String,
	}

	return career, nil
}

// DeleteCareer is the resolver for the deleteCareer field.
func (r *mutationResolver) DeleteCareer(ctx context.Context, id int) (bool, error) {
	// Check if the career exists
	_, err := r.DB.GetCareerByID(ctx, int32(id))
	if err != nil {
		if isSQLError(err, "no career found with this ID") {
			return false, fmt.Errorf("career with ID %d not found", id)
		}
		return false, err
	}

	// Delete the career
	err = r.DB.DeleteCareerByID(ctx, int32(id))
	if err != nil {
		return false, fmt.Errorf("failed to delete career with ID %d: %v", id, err)
	}

	return true, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, filter *customTypes.UserFilter) ([]*customTypes.User, error) {
	if filter != nil {
		fmt.Println("filter", filter)
		if filter.Email != nil {
			users, err := r.DB.GetUsersByEmail(ctx, *filter.Email)
			fmt.Println(err)
			var userPointers []*customTypes.User
			for _, user := range users {
				newUser := &customTypes.User{
					FullName: user.FullName,
					Email:    user.Email,
					ID:       int(user.ID),
					Role:     customTypes.UserRole(user.UserType),
				}
				userPointers = append(userPointers, newUser)
			}
			return userPointers, nil
		} else if filter.Role != nil {
			userRole, _ := convertStringToUserRole(filter.Role.String())

			users, err := r.DB.GetUsersByUserType(ctx, userRole)
			fmt.Println(err)
			var userPointers []*customTypes.User
			for _, user := range users {
				newUser := &customTypes.User{
					FullName: user.FullName,
					Email:    user.Email,
					ID:       int(user.ID),
					Role:     customTypes.UserRole(user.UserType),
				}
				userPointers = append(userPointers, newUser)
			}
			return userPointers, nil

		} else {
			userRole, _ := convertStringToUserRole(filter.Role.String())

			args := &db_sqlc.GetUsersByEmailAndUserTypeParams{
				Email:    *filter.Email,
				UserType: userRole,
			}
			users, err := r.DB.GetUsersByEmailAndUserType(ctx, *args)
			fmt.Println(err)
			var userPointers []*customTypes.User
			for _, user := range users {
				newUser := &customTypes.User{
					FullName: user.FullName,
					Email:    user.Email,
					ID:       int(user.ID),
					Role:     customTypes.UserRole(user.UserType),
				}
				userPointers = append(userPointers, newUser)
			}
			return userPointers, nil

		}
	} else {
		users, err := r.DB.GetAllUsers(ctx)
		fmt.Println(err)
		var userPointers []*customTypes.User
		for _, user := range users {
			newUser := &customTypes.User{
				FullName: user.FullName,
				Email:    user.Email,
				ID:       int(user.ID),
				Role:     customTypes.UserRole(user.UserType),
			}
			userPointers = append(userPointers, newUser)
		}
		return userPointers, nil

	}
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id int) (*customTypes.User, error) {
	user, err := r.DB.GetUserByID(ctx, int32(id))
	fmt.Println(err)
	newUser := &customTypes.User{
		FullName: user.FullName,
		Email:    user.Email,
		ID:       int(user.ID),
		Role:     customTypes.UserRole(user.UserType),
	}

	return newUser, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

func isSQLError(err error, msg string) bool {
	return strings.Contains(err.Error(), msg)
}

var emptyUser db_sqlc.User

func convertStringToUserRole(userType string) (db_sqlc.UserRole, error) {
	switch userType {
	case "JOBSEEKER":
		return db_sqlc.UserRoleJobseeker, nil
	case "ADMIN":
		return db_sqlc.UserRoleAdmin, nil
	case "RECRUITER":
		return db_sqlc.UserRoleRecruiter, nil
	default:
		return db_sqlc.UserRole(""), fmt.Errorf("unsupported user type: %s", userType)
	}
}
